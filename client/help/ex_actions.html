<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
		"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset='UTF-8'">
	<title>Help Index</title>
	<link rel="stylesheet" type="text/css" href="../libraries/reset-min.css"/>
	<link rel="stylesheet/less" type="text/css" href="help.less"/>
	<script src="../libraries/less-1.3.3.min.js"></script>
</head>
<body>
	<h1>Examples: actions</h1>

	<p>
		The most common way to allow the player to do something is to return
		a list of actions from the <code>Actions()</code> subroutine.
	</p>
<pre>
sub Actions
	return [
		Action("Climb out of the hole.",
			'topofwell')
	]
endsub
</pre>
	<p>
		<code>[...]</code> describes a list; each call to <code>Action()</code>
		creates a new action. You can have as many as you like (although
		too many can be confusing to the player).
	</p>
	<p>
		The first parameter to <code>Action()</code> is some markup, which
		is the description to be presented to the user. The second is the
		<i>consequence</i>, which determines what will happen if the user
		selects the action. If it is a string, as above, then the player will
		be moved to the specified room.
	</p>
	<p>
		The following demonstrates some other things that can be done:
	</p>
<pre>
sub Actions
	return [
		Action("Press the button.",
			"Nothing happens."),
		Action("Pull the lever.",
			PullLever)
	]
endsub

sub PullLever
	$leverPulled = true
	player.tell("You pull the lever.")
	room.tell("{player} pulls the lever.")
endsub
</pre>
	<p>
		The first action supplies markup as the consequence (notice that it's
		delimited in double quotes rather than in single quotes). In this
		case, then the message is automatically presented to the user.
	</p>
	<p>
		The second example refers to another subroutine in the room script.
		When the action is performed, the subroutine is called. You can see
		that the subroutine sets a global variable and then reports what
		has happened. Reporting happens twice: once for the player that
		performed the action, and once for everyone else. This is a very
		common idiom.
	</p>
	<p>
		Action lists can be built incrementally:
	</p>
<pre>
sub Actions
	a = [Action("Press the button.", "Nothing happens.")]
	if $leverPulled = true then
		a = a + [Action("Push the lever.", PushLever)]
	else
		a = a + [Action("Pull the lever.", PullLever)]
	endif
	return a
endsub
</pre>
	<p>
		However: notice that now the list of actions changes depending on
		the value of <code>$leverPulled</code>. This means that if we
		<i>change</i> <code>$leverPulled</code>, we need to ensure that the
		set of actions seen by the player is updated. This can be done as
		follows:
	</p>
<pre>
sub PullLever
	$leverPulled = true
	room.refreshActions()

	player.tell("You pull the lever.")
	room.tell("{player} pulls the lever.")
endsub
</pre>
	<p>
		(<code>PushLever</code> will be similar.)
	</p>
	<p>
		Actions do not need to be confined to the action list at the bottom
		of the screen. They can be placed in any markup.
	</p>
<pre>
sub ExamineLever
	player.tell("The lever looks like you can
		{Action("pull it", PullLever)}.")
endsub
</pre>
	<p>
		This is using <code>{...}</code> to embed an expression inside
		markup; that expression is an action. This will be displayed
		to the user as a hyperlink.
	</p>
	<p>
		Be careful with this, because once an action like this is on the
		screen it won't go away again if the room state changes, which
		means the user can pull the lever even once the lever has been
		removed. The most common use for this is to embed hyperlinks inside
		the room description.
	</p>
</body>
</html>

