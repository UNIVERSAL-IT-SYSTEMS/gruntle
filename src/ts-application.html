<link href="https://fonts.googleapis.com/css?family=Lora:400,400italic,700,700italic" rel="stylesheet" type="text/css">
<link rel="import" href="../bower_components/iron-pages/iron-pages.html">
<link rel="import" href="../bower_components/iron-icon/iron-icon.html">
<link rel="import" href="../bower_components/iron-icons/social-icons.html">
<link rel="import" href="../bower_components/paper-button/paper-button.html">
<link rel="import" href="../bower_components/paper-dialog/paper-dialog.html">
<link rel="import" href="../bower_components/paper-spinner/paper-spinner.html">
<link rel="import" href="../bower_components/neon-animation/neon-animated-pages.html">
<link rel="import" href="../bower_components/neon-animation/neon-animatable.html">
<link rel="import" href="ts-auth.html">
<link rel="import" href="ts-editor.html">
<link rel="import" href="ts-game-page.html">
<link rel="import" href="ts-game-settings.html">
<link rel="import" href="ts-globals.html">
<link rel="import" href="ts-hub.html">
<link rel="import" href="ts-login.html">
<link rel="import" href="ts-map.html">
<link rel="import" href="ts-rooms.html">
<link rel="import" href="ts-transcript.html">
<link rel="import" href="ts-user-preferences.html">
<link rel="import" href="ts-welcome.html">
<link rel="import" href="ts-world.html">

<dom-module id="ts-application">
<template>
	<style>

	:host {
		@apply(--layout-fit);
		background-color: var(--paper-blue-grey-100);
		overflow: hidden;

	}

	#page {
		@apply(--layout-fit);
		overflow: hidden;
	}

	#loading, #login, #welcome {
		@apply(--layout-fit);
		@apply(--layout-center-center);
		@apply(--layout-vertical);
	}

	@media (min-width: 700px) {
		.big-dialogue {
			position: fixed;
			left: 1em;
			top: 2em;
			right: 1em;
			bottom: 2em;
			margin: 0;
		}
	}
	@media (max-width: 700px) {
		.big-dialogue {
			position: fixed;
			left: 0;
			top: 0;
			right: 0;
			bottom: 0;
			margin: 0;
		}
	}

	:host > paper-dialog {
	}

	paper-dialog > *:first-child {
		margin-top: 1em;
	}

	paper-dialog > *:last-child {
		margin-bottom: 0;
	}

	</style>

	<ts-globals id="globals">
	</ts-globals>

	<ts-auth id="auth"
		on-auth-success="onAuthSuccess"
		on-auth-failure="onAuthFailure"
		on-server-error="onServerError"
		>
	</ts-auth>

	<ts-world id="world"
		on-world-changed="onWorldChanged"
		>
	</ts-world>

	<ts-hub id="hub"
		on-new-world-available="onNewWorldAvailable"
		>
	</ts-hub>

	<ts-rooms id="rooms"
		on-world-changed="onWorldChanged"
		on-hyperspace="onHyperspaceJump"
		on-user-action="onUserAction"
		>
	</ts-rooms>

	<paper-dialog id="editorDialogue" modal="true" class="big-dialogue">
		<ts-editor id="editor"></ts-editor>
	</paper-dialog>

	<paper-dialog id="mapDialogue" modal="true" class="big-dialogue">
		<ts-map id="map"
			on-edit-request="onEditRequest"
			></ts-map>
	</paper-dialog>

	<ts-game-settings id="settingsDialogue" modal="true" class="big-dialogue">
	</ts-game-settings>

	<ts-user-preferences id="preferencesDialogue" modal="true">
	</ts-user-preferences>

	<paper-dialog id="implicitCreationDialogue">
		<h2>Create room?</h2>
		<p>
			This room has been referred to by an action in another room, but
			hasn't been created yet. Do you want to create it now?
		</p>
		<div class="buttons">
			<paper-button dialog-dismiss>No</paper-button>
			<paper-button dialog-confirm autofocus on-click="onConfirmEdit">Yes</paper-button>
		</div>
    </paper-dialog>

	<iron-pages id="page" selected="0">
		<div id="loading">
			<paper-spinner active></paper-spinner>
		</div>

		<ts-game-page id="game"
			on-edit-request="onEditRequest"
			on-preferences-request="onPreferencesRequest"
			on-settings-request="onSettingsRequest"
			on-map-request="onMapRequest"
			on-logout-request="onLogoutRequest"
			on-talk-request="onTalkRequest"
			is-author="{{isAuthor}}"
			is-single-player="{{isSinglePlayer}}"
			></ts-game-page>

		<ts-login id="login"
			on-click="doExplicitLogin"
			></ts-login>

		<ts-welcome id="welcome"
			on-load-request="onLoadRequest"
			on-create-request="onCreateRequest"
			></ts-welcome>
	</iron-pages>
</template>
<script>
(function () {
"use strict";

let $ = null;
let G = null;

class Player {
	constructor() {
	}

	get location() {
		let name = G.hub.playerNode.get("location");
		if (!name)
			return null;

		return G.rooms.get(name);
	}

	set location(v) {
		G.hub.playerNode.set("location", v.id);
	}

	get name() {
		return G.hub.playerNode.get("useName");
	}

	set name(v) {
		G.hub.playerNode.set("useName", v);
	}

	get id() {
		return G.hub.myself.userId;
	}
}

Polymer({
	is: "ts-application",
	properties: {
		isAuthor: Boolean,
		isSinglePlayer: Boolean
	},

	ready: function() {
		$ = this.$;
		G = $.globals.G;
		G.world = $.world;
		G.hub = $.hub;
		G.rooms = $.rooms;

		/* If there's a state parameter supplied by Google Drive,, reform it to
		 * something we understand. */

		if (G.URI.queryKey.state) {
			let state = JSON.parse(decodeURIComponent(G.URI.queryKey.state));
			switch (state.action) {
				case "open": {
					let id = state.ids[0];
					window.history.replaceState(null, "",
						`${G.URI.path}?id=${id}`); 
					G.URI.queryKey.id = id;
					break;
				}

				case "create": {
					G.URI.queryKey.action = "create";
					G.URI.queryKey.title = state.title;
					G.URI.queryKey.folderId = state.folderId;
					break;
				}

				default:
					console.log("unrecognised google action", state);
			}
		}

		this.doImplicitLogin();
	},

	doImplicitLogin: function() {
		$.page.selected = 0;
		$.auth.authenticate(true);
	},

	doExplicitLogin: function() {
		$.page.selected = 0;
		$.auth.authenticate(false);
	},

	onServerError: function(e) {
		console.log("server error", e);
		//location.reload();
	},

	onAuthSuccess: function() {
		if (G.URI.queryKey.id != null) {
			$.world.documentId = G.URI.queryKey.id;
			$.world.connect().then(
				() => this.onDocumentConnected()
			).catch(
				(e) => this.onServerError(e)
			);
		} else if (G.URI.queryKey.action == "create") {
			this.onCreateRequest(
				{
					title: G.URI.queryKey.title,
					folderId: G.URI.queryKey.folderId
				}
			);
		} else
			$.page.selected = 3;
	},

	onAuthFailure: function(e, f) {
		console.log(e, f);
		$.page.selected = 2;
	},

	onLoadRequest: function(e, id) {
		$.page.selected = 0;
		window.location = `${G.URI.path}?id=${id}`;
	},

	onCreateRequest: function(e, params={}) {
		$.page.selected = 0;

		if (params.title == null)
			params.title = "My new Gruntle game";

		$.world.create(params.title, params.folderId).then(
			(id) => {
				window.location = `${G.URI.path}?id=${id}`;
			}
		);
	},

	onDocumentConnected: function() {
		console.log("connected");

		G.hub.worldId = G.world.documentId;
		G.hub.hubId = G.world.data.settings.hubId;
		G.hub.connect().then(
			() => this.onHubConnected()
		);
	},

	onHubConnected: function() {
		console.log("hub connected");

		this.isSinglePlayer = !G.hub.hubRT.isInGoogleDrive;
		console.log(`This game is ${this.isSinglePlayer ? "single player" : "multi player"}`);

		this.isAuthor = G.world.isAuthor;
		console.log(`I am ${this.isAuthor ? "the author" : "not the author"}`);

		G.player = new Player;
		if (!G.player.name)
			G.player.name = G.hub.myself.displayName;
		console.log("my usename is", G.player.name);

		if (!G.player.location)
		{
			let entrypoint = G.world.data.settings.entrypoint;
			G.player.location = G.rooms.get(entrypoint);
		}

		this.onPlayerLocationChanged(
			{
				oldValue: null,
				newValue: G.player.location.id
			}
		);

		G.hub.playerNode.addEventListener(
			gapi.drive.realtime.EventType.VALUE_CHANGED,
			(e) => {
				if (e.oldValue == e.newValue)
					return;

				switch (e.property) {
					case "location": return this.onPlayerLocationChanged(e);
				}
			}
		);

		G.player.location.tellOthers(G.player, `${G.player.name} teleports in.`);

		$.page.selected = 1;
	},

	onPlayerLocationChanged: function(e) {
		let oldRoom = e.oldValue ? G.rooms.get(e.oldValue) : null;
		let newRoom = G.player.location;

		/* If this is a bad room name, put the player back at the entrypoint. */

		if (!newRoom.exists) {
			this.onHyperspaceJump(null, oldRoom);
			return;
		}

		let parsed = newRoom.parse();
		G.transcript.newRoom(
			{
				title: parsed.title,
				bodyDom: parsed.dom,
				choicesDom: parsed.choicesDom
			}
		);

		if (this.roomQueue)
			this.roomQueue.detach();

		this.roomQueue = new G.MessageQueue(
			G.player.location.log,
			(e) => this._onRoomEvent(e)
		);
	},

	_onRoomEvent: function(e) {
		switch (e.kind) {
			case "tellOthers":
				if (e.player != G.player.id)
					G.transcript.append(e.text);
				break;

			case "tell":
				if (e.player == G.player.id)
					G.transcript.append(e.text);
				break;

			case "broadcast":
				G.transcript.append(e.text);
				break;

			default:
				console.log("unhandled event", e);
				break;
		}
	},

	onEditRequest: function(e, id) {
		let room = G.rooms.get(id);
		if (room.exists) {
			$.editor.room = G.rooms.get(id);
			$.editorDialogue.open();
		} else {
			$.implicitCreationDialogue.roomId = id;
			$.implicitCreationDialogue.open();
		}
	},

	onConfirmEdit: function(e) {
		$.editor.room = G.rooms.createRoom($.implicitCreationDialogue.roomId);
		$.editorDialogue.open();
	},
		
	onSettingsRequest: function() {
		$.settingsDialogue.fit();
		$.settingsDialogue.init();
		$.settingsDialogue.open();
	},

	onPreferencesRequest: function() {
		$.preferencesDialogue.fit();
		$.preferencesDialogue.open();
	},

	onMapRequest: function() {
		$.mapDialogue.fit();
		$.mapDialogue.open();
	},

	onLogoutRequest: function() {
		window.location = G.URI.path;
	},

	onTalkRequest: function(e, s) {
		G.player.location.tellOthers(G.player, `${G.player.name} says, "${s}"`);
		G.player.location.tell(G.player, `You say "${s}"`);
	},

	onDocumentDisconnected: function() {
		console.log("disconnected");
	},

	onArrivalsDepartures: function(e, changes) {
		console.log("arriving/departing", changes);
	},

	onNewWorldAvailable: function(e) {
		G.world.reload();
	},

	onWorldChanged: function(event) {
		if ((G.player != null) && (G.player.location != null)) {
			let parsed = G.player.location.parse();
			G.transcript.updateRoom(
				{
					title: parsed.title,
					bodyDom: parsed.dom,
					choicesDom: parsed.choicesDom
				}
			);
		}
		$.map.updateMap();
	},

	onHyperspaceJump: function(e, oldRoom) {
		if (oldRoom) {
			oldRoom.tell(G.player, `[That bit of the world hasn't been built yet.]`);
		} else {
			let entrypoint = G.worldConfig.get("entrypoint");
			G.player.location = G.rooms.get(entrypoint);
		}
	},

	onUserAction: function(e, actions) {
		G.transcript.hideChoices();
		G.transcript.setMark();

		const actionHandler = {
			tellPlayerAction: (text) => G.player.location.tell(G.player, text),
			tellOthersAction: (text) => G.player.location.tellOthers(G.player, text),
			tellAllAction:    (text) => G.player.location.broadcast(text),

			gotoAction: (name) => {
				let room = G.rooms.get(name);
				if (!room.exists)
					this.onHyperspaceJump(null, G.player.location);
				else {
					G.transcript.scrollToMark();
					G.player.location.tellOthers(G.player, `${G.player.name} goes to ${room.parse().title}.`);
					room.tellOthers(G.player, `${G.player.name} arrives from ${G.player.location.parse().title}.`);
					G.player.location = room;
				}
			}
		};

		for (let [action, arg] of actions)
			actionHandler[action](arg);

		/* TODO: fix this, it's horrible. This gives enough time for the event
		 * handlers to fire and tell the transcript what to do, so showChoices()
		 * always runs last. */
		this.async(() => G.transcript.showChoices(), 500);
	},
});


})();
</script>
</dom-module>
