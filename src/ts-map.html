<script src="../bower_components/lodash/lodash.min.js"></script>
<script src="../bower_components/graphlib/dist/graphlib.core.js"></script>
<script src="../bower_components/dagre/dist/dagre.core.min.js"></script>
<script src="../bower_components/d3/d3.min.js"></script>
<script src="../bower_components/dagre-d3/dist/dagre-d3.core.min.js"></script>
<link rel="import" href="../bower_components/iron-dropdown/iron-dropdown.html">
<link rel="import" href="../bower_components/paper-button/paper-button.html">
<link rel="import" href="../bower_components/paper-dialog-behavior/paper-dialog-behavior.html">
<link rel="import" href="../bower_components/paper-dialog-behavior/paper-dialog-shared-styles.html">
<link rel="import" href="../bower_components/paper-item/paper-item.html">
<link rel="import" href="../bower_components/paper-menu/paper-menu.html">
<link rel="import" href="ts-globals.html">

<style>
	svg#map .node rect {
		stroke: #000;
		fill: #fff;
	}

	svg#map .node:hover {
		stroke-width: 2.5px !important;
	}

	svg#map .node.fake rect {
		fill: #f88;
	}

	svg#map .node.entrypoint rect {
		fill: #ff8;
	}

	svg#map .edgePath path {
		stroke: #000;
		stroke-width: 1.5px;
	}
</style>

<dom-module id="ts-map">
<style include="paper-dialog-shared-styles">
	:host {
		@apply(--layout-fit);
		@apply(--layout-vertical);
	}

	#mapContainer {
		@apply(--layout-flex);
		overflow: hidden;
		display: block;
		padding-left: 0;
		padding-right: 0;
	}

	#map {
		width: 100vw;
		height: 100vh;
	}

	svg {
		background-color: var(--paper-blue-grey-100);
	}
	
	#controls {
		position: absolute;
		left: 1em;
		bottom: 1em;
	}

	#dropdown paper-menu {
        padding: 12px;
		@apply(--shadow-elevation-6dp);
	}
</style>

<template>
	<ts-globals id="globals"></ts-globals>

	<h2>Map</h2>
	<div id="mapContainer" class="relative">
		<svg id="map"><g/></svg>
		<div id="controls" class="layout vertical">
			<paper-button raised>Create room</paper-button>
		</div>
	</div>

	<div class="buttons">
		<paper-button dialog-dismiss>Close</paper-button>
	</div>

	<iron-dropdown id="dropdown"
		vertical-align="top"
		horizontal-align="left"
		vertical-offset="0"
		horizontal-offset="0"
		>
		<paper-menu>
			<paper-item>Edit</paper-item>
			<paper-item>Make the entrypoint</paper-item>
			<paper-item>Rename</paper-item>
			<paper-item>Delete</paper-item>
		</paper-menu>
	<iron-dropdown>
</template>
<script>
(function () {
"use strict";

let G;

let class_for_room = (id) =>
	"room_class_" + encodeURIComponent(id);

Polymer({
	is: "ts-map",
	properties: {
	},
	behaviors: [
		Polymer.PaperDialogBehavior
	],
	observers: [
		"onOpenClose(opened)",
	],

	ready: function() {
		G = this.$.globals.G;
		this.drawn = false;
	},

	updateMap: function() {
		let $ = this.$;

		/* Only update the map if we're visible. */

		console.log("map width is ", $.mapContainer.offsetWidth);
		if ($.mapContainer.offsetWidth == 0)
			return;

		/* Construct the map from the room data. */
		
		let rooms = G.rooms.getAll();
		let nodes = [];
		let edges = [];

		for (let r of rooms) {
			let parsed = r.parse();
			nodes.push(r);

			for (let exit of parsed.exits) {
				if (!G.rooms.get(exit).exists)
					nodes.push(
						{
							id: exit,
							fake: true
						}
					);

				edges.push(
					{
						from: r.id,
						to: exit
					}
				);
			}
		}

		/* Remove the old graph. */

		d3.select($.map).select("g *").remove();

		/* Now render the graph to the canvas. */

		let svg = d3.select($.map);
		let inner = svg.select("g");

		let g = new dagreD3.graphlib.Graph().setGraph({});

		for (let room of nodes) {
			let classes = [class_for_room(room.id)];
			if (room.fake)
				classes.push("fake");
			if (room.id == G.world.data.settings.entrypoint)
				classes.push("entrypoint");

			g.setNode(room.id,
				{
					label: room.id,
					class: classes.join(" "),
				}
			);
		}

		for (let edge of edges) {
			g.setEdge(edge.from, edge.to,
				{
					lineInterpolate: "basis"
				}
			);
		}

		/* Actually render it. */

		(new dagreD3.render())(inner, g);

		/* Add click behaviours. */

		let onClick = (d, i) => {
			let node = d3.select("." + class_for_room(d))[0][0];
			console.log(node);
			$.dropdown.positionTarget = node;
			$.dropdown.open();
		};
		svg.selectAll(".node rect").on("click", onClick);
		svg.selectAll(".node tspan").on("click", onClick);

		/* If this is the first time the map has been shown, set up the zoom/drag
		 * behaviours and centre it. */

		if (!this.drawn) {
			let zoom = d3.behavior.zoom().on("zoom",
				() => inner.attr(
					"transform", "translate(" + d3.event.translate + ")" +
						"scale(" + d3.event.scale + ")")
			);
			svg.call(zoom);

			let scale = 0.75;
			let width = $.mapContainer.offsetWidth;
			let height = $.mapContainer.offsetHeight;
			zoom
				.translate([
					(width - g.graph().width * scale) / 2,
					(height - g.graph().height * scale) / 2
				])
				.scale(scale)
				.event(svg);
		}

		this.drawn = true;
	},

	onOpenClose: function(opened) {
		let $ = this.$;

		if (opened) {
			/* This is some horrible, horrible, horrible code which waits until
			 * the map container gets sized. I haven't found a sane, portable
			 * way of doing this more cleanly. */

			let f = () => {
				if ($.mapContainer.offsetWidth > 0)
					this.updateMap();
				else {
					console.log("waiting for map sizing...");
					setTimeout(f, 10);
				}
			};
			f();
		} else {
			d3.select(this.$.map).on(".zoom", null);
			this.drawn = false;
		}
		console.log("map opened = ", opened);
	},
});


})();
</script>
</dom-module>


