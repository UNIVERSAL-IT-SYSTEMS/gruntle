<link rel="import" href="ts-globals.html">

<dom-module id="ts-document">
<template>
	<style>
	  :host {
		display: none;
	  }
	</style>

	<ts-globals id="globals"></ts-globals>
</template>
<script>
(function () {
"use strict";

let G;

const defaultDocument = {
	settings: {
		entrypoint: "entrypoint",
		hub_id: "private"
	},
	rooms: {
		entrypoint: {
			text: `
#title My First Room

This is the first and only room in my brand new game.
Eventually this will be replaced with a rather more 
useful template. We Apologise For The Inconvenience.

To add more rooms, edit this one and add exits --- the
new rooms will appear automatically on the map. (This
all needs smoothing out.)

Note that this game is set to single player mode by
default. You can change this in the settings. Remember
you still need to share it with someone before they can
play (go to the Drive UI to do that).
`
		},
	},
};

Polymer({
	is: "ts-document",
	properties: {
		worldDocument: String,
	},

	ready: function() {
		G = this.$.globals.G;

		this.people = new Map();
	},

	connect: function() {
		gapi.client.drive.files.get(
			{
				fileId: this.worldDocument,
				alt: "media",
			}
		).then(
			(r) =>
				console.log(r)
		);

		return;
		this.loginPromise.then(
			() => new Promise(
				(pass, fail) =>
					gapi.drive.realtime.load(
						this.worldDocument,
						(worldDoc) => {
							this.world = worldDoc;
							this.worldRoot = worldDoc.getModel().getRoot();
							pass();
						},
						(worldDoc) => this._onInitialise(worldDoc),
						fail
					)
			)
		).then(
			() => {
				console.log("document loaded");
				console.log("world revision:", this.world.getModel().serverRevision);

				let config = this.worldRoot.get("config");
				let hubDocument = null;
				if (config != null)
					hubDocument = config.get("hubDocument");

				if ((hubDocument == null) || (hubDocument == "private")) {
					console.log("using in-memory hub");
					return new Promise(
						(pass, fail) =>
							gapi.drive.realtime.newInMemoryDocument(
								(hubDoc) => {
									this.hub = hubDoc;
									this.hubRoot = hubDoc.getModel().getRoot();
									pass();
								},
								null,
								fail
							)
					);
				} else if (hubDocument == "this") {
					console.log("using this document as a hub");
					this.hub = this.world;
					this.hubRoot = this.worldRoot;
				} else {
					console.log("hub document:", hubDocument);
					return new Promise(
						(pass, fail) =>
							gapi.drive.realtime.load(
								hubDocument,
								(hubDoc) => {
									this.hub = hubDoc;
									this.hubRoot = hubDoc.getModel().getRoot();
									pass();
								},
								null,
								fail
							)
					);
				}
			}
		).then(
			() => {
				console.log("document loaded");
				console.log("hub revision:", this.hub.getModel().serverRevision);

				this.world.addEventListener(
					gapi.drive.realtime.EventType.COLLABORATOR_JOINED,
					() => this._onCollaboratorsChanged());
				this.world.addEventListener(
					gapi.drive.realtime.EventType.COLLABORATOR_LEFT,
					() => this._onCollaboratorsChanged());

				this.fire("connected");
				this._onCollaboratorsChanged();
			}
		).catch(
			(e) => console.log(e)
		);
	},

	createFile: function(filename) {
		gapi.client.drive.files.insert(
			{
				mimeType: G.MIME_TYPE,
				title: filename
			}
		).then(
			(r) => r.result.id
		);
	},

	getFile: function(id, json) {
		gapi.client.drive.realtime.get(
			{
				fileId: id
			}
		).then(
			(r) => r
		);
	},
	
	_onConnectionError: function(e) {
		console.log("connection error " + e);
		this.fire("connection-error", e);
	},

	_onSignOut: function(e) {
		console.log("signout");
		this.fire("disconnected", e);
	},

	_onCollaboratorsChanged: function() {
		/* Get the uniquified list of people. */

		let people = {};
		for (let c of this.world.getCollaborators()) {
			people[c.userId] = c;
			if (c.isMe && !this.myself)
			{
				this.myself = c;
				this.fire("player-visible", c);
			}
		}

		let arriving = Object.keys(people).filter(p => !(p in this.people));
		let departing = Object.keys(this.people).filter(p => !(p in people));

		if ((arriving.length > 0) || (departing.length > 0)) {
			this.people = people;
			this.fire("arrivals-departures",
				{
					arriving: arriving,
					departing: departing
				});
		}
	},

	_onInitialise: function(model) {
	},
});

})();
</script>
</dom-module>

