<link rel="import" href="../bower_components/google-apis/google-js-api.html">
<link rel="import" href="ts-globals.html">

<dom-module id="ts-document">
<template>
	<style>
	  :host {
		display: none;
	  }
	</style>

	<ts-globals id="globals"></ts-globals>
	<google-js-api id="api"></google-js-api>
</template>
<script>
(function () {
"use strict";

let G;

Polymer({
	is: "ts-document",
	properties: {
		worldDocument: String,
	},

	ready: function() {
		G = this.$.globals.G;

		this.people = new Map();

		this.apiLoadPromise = new Promise(
			(pass, fail) =>
				this.$.api.addEventListener("js-api-load", pass)
		).then(
			() => new Promise(
				(pass, fail) =>
					gapi.load("auth:client,drive-realtime,picker", pass, fail)
			)
		).then(
			() => gapi.client.load("drive", "v2")
		).then(
			() => console.log("api loaded")
		);

	},

	authenticate: function(silent) {
		if (silent == null)
			silent = true;

		this.loginPromise = this.apiLoadPromise.then(
			() => new Promise(
				(pass, fail) => {
					gapi.auth.authorize(
						{
							client_id: G.CLIENT_ID,
							scope: G.SCOPES,
							immediate: silent
						},
						(r) => {
							if (r && !r.error)
								pass();
							else
								fail(r);
						}
					);
				}
			)
		).then(
			() => {
				/* Enable token refresh every 45 minutes. */
				setTimeout(
					() => {
						console.log("refreshing auth token");
						gapi.auth.authorize(
							{
								client_id: G.CLIENT_ID,
								scope: G.SCOPES,
								immediate: true
							},
							(r) => {
								if (!r || !r.error)
									this.fire("server-error", e);
							}
						);
					},
					45 * 60 * 1000
				);
				this.fire("auth-success");
			}
		).catch(
			(e) => this.fire("auth-failure", e)
		);
	},
		
	create: function(title, folderId) {
		return this.loginPromise.then(
			() => new Promise(
				(pass, fail) => {
					let parents = folderId ? [folderId] : null;

					gapi.client.drive.files.insert(
						{
							resource: {
								mimeType: G.MIME_TYPE,
								title: title,
								parents: parents
							}
						}
					).execute(
						(r) => {
							if (r.result)
								pass(r.result.id);
							else
								fail(r);
						}
					);
				}
			)
		);
	},

	connect: function() {
		this.loginPromise.then(
			() => new Promise(
				(pass, fail) =>
					gapi.drive.realtime.load(
						this.worldDocument,
						(worldDoc) => {
							this.world = worldDoc;
							this.worldRoot = worldDoc.getModel().getRoot();
							pass();
						},
						(worldDoc) => this._onInitialise(worldDoc),
						fail
					)
			)
		).then(
			() => {
				console.log("document loaded");
				console.log("world revision:", this.world.getModel().serverRevision);

				let config = this.worldRoot.get("config");
				let hubDocument = null;
				if (config != null)
					hubDocument = config.get("hubDocument");

				if ((hubDocument == null) || (hubDocument == "private")) {
					console.log("using in-memory hub");
					return new Promise(
						(pass, fail) =>
							gapi.drive.realtime.newInMemoryDocument(
								(hubDoc) => {
									this.hub = hubDoc;
									this.hubRoot = hubDoc.getModel().getRoot();
									pass();
								},
								null,
								fail
							)
					);
				} else if (hubDocument == "this") {
					console.log("using this document as a hub");
					this.hub = this.world;
					this.hubRoot = this.worldRoot;
				} else {
					console.log("hub document:", hubDocument);
					return new Promise(
						(pass, fail) =>
							gapi.drive.realtime.load(
								hubDocument,
								(hubDoc) => {
									this.hub = hubDoc;
									this.hubRoot = hubDoc.getModel().getRoot();
									pass();
								},
								null,
								fail
							)
					);
				}
			}
		).then(
			() => {
				console.log("document loaded");
				console.log("hub revision:", this.hub.getModel().serverRevision);

				this.world.addEventListener(
					gapi.drive.realtime.EventType.COLLABORATOR_JOINED,
					() => this._onCollaboratorsChanged());
				this.world.addEventListener(
					gapi.drive.realtime.EventType.COLLABORATOR_LEFT,
					() => this._onCollaboratorsChanged());

				this.fire("connected");
				this._onCollaboratorsChanged();
			}
		).catch(
			(e) => console.log(e)
		);
	},

	createFile: function(filename) {
		return this.loginPromise.then(
			() => gapi.client.drive.files.insert(
				{
					mimeType: G.MIME_TYPE,
					title: filename
				}
			)
		).then(
			(r) => r.result.id
		);
	},

	getFile: function(id, json) {
		return this.loginPromise.then(
			() => gapi.client.drive.realtime.get(
				{
					fileId: id
				}
			)
		).then(
			(r) => r
		);
	},
	
	_onConnectionError: function(e) {
		console.log("connection error " + e);
		this.fire("connection-error", e);
	},

	_onSignOut: function(e) {
		console.log("signout");
		this.fire("disconnected", e);
	},

	_onCollaboratorsChanged: function() {
		/* Get the uniquified list of people. */

		let people = {};
		for (let c of this.world.getCollaborators()) {
			people[c.userId] = c;
			if (c.isMe && !this.myself)
			{
				this.myself = c;
				this.fire("player-visible", c);
			}
		}

		let arriving = Object.keys(people).filter(p => !(p in this.people));
		let departing = Object.keys(this.people).filter(p => !(p in people));

		if ((arriving.length > 0) || (departing.length > 0)) {
			this.people = people;
			this.fire("arrivals-departures",
				{
					arriving: arriving,
					departing: departing
				});
		}
	},

	_onInitialise: function(model) {
		let root = model.getRoot();

		let config = model.createMap();
		root.set("config", config);
		config.set("entrypoint", "entrypoint");
		config.set("hubDocument", "private");

		let rooms = model.createMap();
		root.set("rooms", rooms);

		let entrypoint = model.createMap();
		rooms.set("entrypoint", entrypoint);

		entrypoint.set("title", model.createString("My first room"));
		entrypoint.set("text", model.createString(
			`This is the first and only room in my brand new game. ` +
			`Eventually this will be replaced with a rather more ` +
			`useful template. We Apologise For The Inconvenience.\n\n` +
			`To add more rooms, edit this one and add exits --- the ` +
			`new rooms will appear automatically on the map. (This ` +
			`all needs smoothing out.)\n\n` +
			`Note that this game is set to single player mode by ` +
			`default. You can change this in the settings. Remember ` +
			`you still need to share it with someone before they can ` +
			`play (go to the Drive UI to do that).`
		));
	},
});

})();
</script>
</dom-module>

