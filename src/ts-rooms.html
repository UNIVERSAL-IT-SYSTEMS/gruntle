<link rel="import" href="ts-parser.html">
<link rel="import" href="ts-globals.html">

<dom-module id="ts-rooms">
<template>
	<ts-globals id="globals"></ts-globals>
	<ts-parser id="parser"></ts-parser>
</template>
<script>
(function () {
"use strict";

let roomstore;
let $;
let G;
let cache = {};

class Room {
	constructor(id) {
		this.id = id;
		this.node = G.worldRooms.get(id);
		this.log = G.ensureList(G.hubDoc, G.hub, this.id);
		this.queue = new G.MessageQueue(this.log);

		let onChange = () => {
			roomstore.async(
				() => roomstore.fire("room-changed", this)
			);
		};

		this.node.get("text").addEventListener(
			gapi.drive.realtime.EventType.OBJECT_CHANGED,
			onChange
		);
	}

	get model() {
		return $.doc.world.getModel();
	}

	get text() {
		return this.node.get("text");
	}
	
	get pendingText() {
		return this._ensurePending("text", "pendingText");
	}

	_ensurePending(original, pending) {
		let p = this.node.get(pending);
		if (!p) {
			let s = this.node.get(original).getText();

			p = G.worldDoc.getModel().createString(s);
			this.node.set(pending, p);
		}
		return p;
	}

	_commitPending(original, pending) {
		let p = this.node.get(pending);
		if (p) {
			let s = p.getText();
			this.node.get(original).setText(s);
		}
	}

	commitPending() {
		this._commitPending("text", "pendingText");
	}

	_revertPending(original, pending) {
		let p = this.node.get(pending);
		if (p)
			p.setText(this.node.get(original).getText());
	}

	revertPending() {
		this._revertPending("text", "pendingText");
	}

}

function loadRoom(id) {
	return new Room(id);
}

Polymer({
	is: "ts-rooms",
	properties: {
		world: HTMLElement,
		hub: HTMLElement,
	},

	ready: function() {
		let $ = this.$;
		let G = $.globals.G;

		this._cache = {};
		this._Room = class Room {
			constructor(id) {
				this.id = id;
				this.log = G.ensureList(G.hub.hubRT, G.hub.roomsNode, this.id);
				this.queue = new G.MessageQueue(this.log);
			}

			get exists() {
				return this.id in G.world.data.rooms;
			}

			get text() {
				return G.world.data.rooms[this.id].text;
			}

			parse() {
				return $.parser.parse(this.text,
					(actions) => G.rooms.fire("user-action", actions)
				);
			}
	
			postEvent(kind, player, text) {
				let e = this.queue.post(kind,
					{
						player: player ? player.id : null,
						text: text,
					}
				);

				console.log(`${e.time}: ${kind} in ${this.id}: ${player ? player.name : 'null'}: ${text}`);
			}

			tell(player, text) {
				this.postEvent("tell", player, text);
			}

			tellOthers(player, text) {
				this.postEvent("tellOthers", player, text);
			}

			broadcast(text) {
				this.postEvent("broadcast", null, text);
			}

			get pendingText() {
				let node = G.world.roomsNode.get(this.id);
				if (node == null) {
					node = G.world.documentRT.getModel().createString(this.text);
					G.world.roomsNode.set(this.id, node);
				}
				return node;
			}
		}
	},

	startWatching: function() {
		$ = this.$;

		G.worldRooms.addEventListener(
			gapi.drive.realtime.EventType.VALUE_CHANGED,
			() =>
				this.fire("room-changed", null)
		);
	},

	get: function(id) {
		let room = this._cache[id];
		if (room == null) {
			room = new this._Room(id);
			this._cache[id] = room;
		}
		return room;
	},

	getAll: function() {
		let rooms = [];
		for (let id in G.world.rooms) {
			rooms.push(this.get(id));
		}
		return rooms;
	},

	createRoom: function(id, text) {
		let r = G.worldDoc.getModel().createMap();
		r.set("text", G.worldDoc.getModel().createString(
			(text != null) ? text : "Room text goes here"
		));
		G.worldRooms.set(id, r);

		return cacheGet(id);
	},
});

})()
</script>
</dom-module>


