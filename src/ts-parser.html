<link rel="import" href="ts-parser.html">

<dom-module id="ts-parser">
<template>
	<ts-globals id="globals"></ts-globals>
</template>
<script>
(function () {
"use strict";

let G;

class ParsedText {
	constructor(source, handler) {
		let dom = document.createElement("div");
		let actions = [];
		let choices = [];
		let currentParagraph = document.createElement("P");
		let currentAction = null;

		function pushParagraph() {
			dom.appendChild(currentParagraph);
			currentParagraph = document.createElement("P");
		}

		function appendTextNode(paragraph, text) {
			let t = document.createTextNode(text);
			paragraph.appendChild(t);
		}

		function appendActionNode(paragraph, text) {
			let a = document.createElement("a");
			a.setAttribute("href", "#");
			appendTextNode(a, text);
			paragraph.appendChild(a);
			return a;
		}

		function appendErrorNode(paragraph, text) {
			let span = document.createElement("span");
			span.className = "error";
			appendTextNode(span, text);
			paragraph.appendChild(span);
		}

		function addLink(link) {
			if (link != null) {
				let action = currentAction = [];
				actions.push(currentAction);
				link.onclick = () => {
					for (let [name, argument] of action)
						handler[name](argument);
				};
			}
		}

		function parseAndAppend(paragraph, text) {
			const re = /((?:\${)|{)([^}]*)}/g;
			let link = null;
			let start = 0;
			for (;;) {
				let result = re.exec(text);
				if (!result) {
					appendTextNode(paragraph, text.slice(start));
					break;
				} else
					appendTextNode(paragraph, text.slice(start, result.index));
				start = re.lastIndex;

				switch (result[1]) {
					case '{':
						link = appendActionNode(paragraph, result[2]);
						break;

					case '${':
					{
						let varname = result[2];
						switch (varname) {
							case 'name':
								appendTextNode(paragraph, G.player.name);
								break;

							default:
								appendErrorNode(paragraph, `unrecognised variable '${varname}'`);
								break;
						}
						break;
					}
				}
			}
			return link;
		}

		function parseActionName(name) {
			switch (name.toLowerCase()) {
				case "goto":       return "onGotoAction";
				case "tellplayer": return "onTellPlayerAction";
				case "tellothers": return "onTellOthersAction";
				case "tellall":    return "onTellAllAction";
			}
		}

		source += '\n';
		for (let line of source.match(/([^\r\n]*)[\r\n]/g)) {
			line = line.trim();
			if (line.match(/^\s*$/)) {
				pushParagraph();
				continue;
			}

			let choiceresult = line.match(/^\-\s+(.*)$/);
			if (choiceresult) {
				let p = document.createElement("P");
				addLink(parseAndAppend(p, choiceresult[1]));
				choices.push(p);
				continue;
			}

			let actionresult = line.match(/^#(\w+)\s+(.*)$/);
			if (actionresult) {
				let name = parseActionName(actionresult[1]);
				if (name)
					currentAction.push([name, actionresult[2]]);
				else
					currentAction.push(["onUnknownAction", name]);
			} else {
				addLink(parseAndAppend(currentParagraph, line));
			}
		}
		pushParagraph();

		this.dom = dom;
		this.actions = actions;
		this.choicesDom = null;

		if (choices.length > 0) {
			this.choicesDom = document.createElement("DIV");

			let p = document.createElement("P");
			appendTextNode(p, "What would you like to do?");
			Polymer.dom(this.choicesDom).appendChild(p);

			let ul = document.createElement("UL");
			Polymer.dom(this.choicesDom).appendChild(ul);

			for (let choice of choices) {
				let li = document.createElement("LI");
				Polymer.dom(li).appendChild(choice);
				Polymer.dom(ul).appendChild(li);
			}
		}
	}

	onAction(action) {
		console.log("action", action);
	}
}

Polymer({
	is: "ts-parser",

	ready: function() {
		G = this.$.globals.G;
	},

	parse: function(text, handler) {
		return new ParsedText(text, handler);
	},

	startWatching: function(world) {
	},
});

})()
</script>
</dom-module>

