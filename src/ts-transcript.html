<link rel="import" href="../bower_components/iron-icons/editor-icons.html">
<link rel="import" href="../bower_components/paper-icon-button/paper-icon-button.html">
<link rel="import" href="ts-transformer.html">
<link rel="import" href="ts-globals.html">

<style>
	.transcript {
		text-rendering: optimizeLegibility;
		font-family: 'Lora', serif;
		text-align: justify;
		line-height: 1.8em;
		overflow-wrap: break-word;
		word-wrap: break-word;
		margin: 0;
		padding: 0;
	}

	.transcript P {
		margin: 0;
		padding-top: 0;
		padding-bottom: 0.5em;
	}

	.transcript H1 {
		font-size: 120%;
		font-weight: bold;
		margin: 0;
		padding-top: 0.5em;
		padding-bottom: 1em;
	}

	.transcript H3 {
		font-size: 100%;
		font-weight: bold;
		margin: 0;
		padding-top: 1em;
		padding-bottom: 0.5em;
	}

	.transcript UL {
		margin: 0;
		padding-top: 0.2em;
		padding-bottom: 0.2em;
		padding-left: 7%;
	}

	.transcript UL P {
		margin: 0;
		padding-bottom: 0.5em;
	}

	.transcript .disabled {
		opacity: 0.6;
		pointer-events: none;

		transition: opacity 2.0s ease-in-out;
	}
</style>

<dom-module id="ts-transcript">
<template>
	<style>

	:host {
		min-height: 100%;
	}

	@media (min-width: 800px) {
		:host {
			font-size: 110%;
		}
	}
	
	#container {
		margin-left: 3%;
		margin-right: 3%;
	}

	#container li p {
		@apply(--transcript-choice);
	}

	#blank {
		height: 100vh;
	}

	#textbox {
		position: fixed;
		bottom: 1em;
		left: 1em;
		right: 1em;
	}
	</style>

	<ts-globals id="globals"></ts-globals>
	<div id="container" class="transcript"></div>
	<div id="blank"></div>
</template>
<script>
(function () {
"use strict";

let G = null;

function createElementWithClass(elementType, c) {
	let e = document.createElement(elementType);
	e.setAttribute("class", c);
	return e;
}

function createDiv(...elements) {
	let div = document.createElement("DIV");
	for (let e of elements)
		div.appendChild(e);
	return div;
}

function createTextNode(elementType, text) {
	let e = document.createElement(elementType);
	let t = document.createTextNode(text);
	e.appendChild(t);
	return e;
}

function empty(element) {
	for (;;) {
		let child = Polymer.dom(element).firstChild;
		if (!child)
			break;
		Polymer.dom(element).removeChild(child);
	}
}

function appendTextNode(paragraph, text) {
	let t = document.createTextNode(text);
	paragraph.appendChild(t);
}

Polymer({
	is: "ts-transcript",
	properties: {
		isAuthor: Boolean,
		scrollTarget: HTMLElement
	},

	ready: function() {
		G = this.$.globals.G;

		this.roomDiv = null;
		this.titleT = null;
		this.bodyT = null;
		this.choicesT = null;
		this.bodyDom = null;
		this.choicesDom = null;
		this.mark = null;

		this._chain = [];
		this._running = false;
	},

	_queue: function(cb) {
		this._chain.push(cb);
		if (!this._running) {
			this._running = true;
			this._consumeQueueItem();
		}
	},

	_consumeQueueItem: function() {
		let next = this._chain.shift();
		if (!next) {
			console.log("queue runner terminate");
			this._running = false;
			return null;
		}

		return new Promise(next).then(
			() => {
				this.fire("new-content");
				this._consumeQueueItem();
			}
		);
	},

	_createTitleNode: function(text, id) {
		let e = document.createElement("H1");
		e.appendChild(document.createTextNode(text));

		if (this.isAuthor) {
			let icon = document.createElement("paper-icon-button");
			icon.icon = "editor:mode-edit";
			icon.addEventListener(
				"click",
				() => this.fire("edit-request")
			);
			e.appendChild(icon);
		}

		return e;
	},

	newRoom: function({title, bodyDom, choicesDom}) {
		this.hideChoices();
		this._queue(
			(pass, fail) => {
				console.log("-> newRoom");
				let $ = this.$;

				if (this.roomDiv) {
					this.roomDiv.className += " disabled";

					for (let e of this.roomDiv.getElementsByTagName("A"))
						e.tabIndex = -1;
				}

				this.roomDiv = createElementWithClass("DIV", "transcript");
				this.titleT = document.createElement("ts-transformer");
				this.bodyT = document.createElement("ts-transformer");
				this.choicesT = document.createElement("ts-transformer");

				this.bodyDom = bodyDom;
				this.choicesDom = choicesDom;

				$.container.appendChild(this.roomDiv);
				this.roomDiv.appendChild(this.titleT);
				this.roomDiv.appendChild(this.bodyT);
				this.roomDiv.appendChild(this.choicesT);

				this.titleT.content = this._createTitleNode(title);
				this.bodyT.content = bodyDom;
				this.choicesT.content = choicesDom;

				this.bodyT.then(pass);
				this.fire("new-content");
			}
		);
	},

	hideChoices: function() {
		this._queue(
			(pass, fail) => {
				console.log("-> hideChoices");
				if (this.choicesT != null) {
					this.choicesT.content = null;
					this.choicesT.then(pass);

					this.fire("new-content");
				} else
					pass();
			}
		);
	},

	showChoices: function() {
		this._queue(
			(pass, fail) => {
				console.log("-> showChoices");
				if (this.choicesT.content != null) {
					/* Choices are already visible. */
					pass();
				} else {
					this.roomDiv.appendChild(this.choicesT);

					this.choicesT.content = this.choicesDom;
					this.choicesT.then(pass);
				}

				this.fire("new-content");
			}
		);
	},

	updateRoom: function({title, bodyDom, choicesDom}) {
		this._queue(
			(pass, fail) => {
				console.log("-> updateRoom");

				this.titleT.content = this._createTitleNode(title);

				this.bodyDom = bodyDom;
				this.choicesDom = choicesDom;

				this.bodyT.content = bodyDom;
				this.choicesT.content = choicesDom;

				this.fire("new-content");
				this.bodyT.then(pass);
			}
		);
	},

	append: function(text) {
		let room = this._currentRoom;
		this._queue(
			(pass, fail) => {
				console.log("-> append", text);
				let t = document.createElement("ts-transformer");
				t.animation = "fast-fade-zoom";
				t.content = createTextNode("P", text);
				this.roomDiv.appendChild(t);

				this.fire("new-content");
				t.then(pass);
			}
		);
	},

	setMark: function() {
		this._queue(
			(pass, fail) => {
				console.log("-> setmark");
				this.mark = createElementWithClass("DIV", "mark");
				this.roomDiv.appendChild(this.mark);

				pass();
			}
		);
	},

	scrollToMark: function() {
		this._queue(
			(pass, fail) => {
				console.log("-> scrollToMark");
				if (this.mark == null)
					return;

				if (this.scrollTarget != null) {
					let a = new KeyframeEffect(
						this.scrollTarget,
						[],
						{
							duration: 1000,
							easing: "ease-in-out"
						}
					);
					let starty = this.scrollTarget.scrollTop;
					a.onsample = (fraction, e, a) => {
						let endy = G.findRelativeYOffset(this.mark, this.scrollTarget);

						if (fraction != null)
							this.scrollTarget.scrollTop = starty - fraction*(starty-endy);
					};

					document.timeline.play(a);
				}
				
				pass();
			}
		);
	},

	isVisible: function(ypos) {
		let fontSize = parseFloat(getComputedStyle(this).getPropertyValue("font-size"));
		let margin = fontSize * 2;
		let windowHeight = this.scrollTarget.offsetHeight;
		let top = this.scrollTarget.scrollTop;
		return (top + windowHeight) > (ypos + margin);
	},

	atBottom: function() {
		return this.isVisible(this.$.container.offsetHeight);
	},
});

})();
</script>
</dom-module>

