<link rel="import" href="ts-transformer.html">

<style>
	.transcript {
		text-rendering: optimizeLegibility;
		font-family: 'Lora', serif;
		text-align: justify;
		line-height: 1.8em;
		overflow-wrap: break-word;
		word-wrap: break-word;
		margin: 0;
		padding: 0;
	}

	.transcript P {
		margin: 0;
		padding-top: 0;
		padding-bottom: 0.5em;
	}

	.transcript H1 {
		font-size: 120%;
		font-weight: bold;
		margin: 0;
		padding-top: 1.5em;
		padding-bottom: 1em;
	}

	.transcript H3 {
		font-size: 100%;
		font-weight: bold;
		margin: 0;
		padding-top: 1em;
		padding-bottom: 0.5em;
	}

	.transcript UL {
		margin: 0;
		padding-top: 0.2em;
		padding-bottom: 0.2em;
	}

	.transcript UL P {
		margin: 0;
		padding-bottom: 0.5em;
	}

</style>

<dom-module id="ts-transcript">
<template>
	<style>

	:host {
		@apply(--layout-vertical);
		display: block;
		min-height: 100%;
		font-size: 110%;
	}

	#container {
		@apply(--layout-flex);
	}

	#container li p {
		@apply(--transcript-choice);
	}

	#blank {
		height: 100vh;
	}

	#textbox {
		position: fixed;
		bottom: 1em;
		left: 1em;
		right: 1em;
	}
	</style>

	<div id="container" class="transcript"></div>
	<div id="blank"></div>
</template>
<script>
(function () {
"use strict";

function divWithClass(c) {
	let e = document.createElement("DIV");
	e.setAttribute("class", c);
	return e;
}

function createDiv(...elements) {
	let div = document.createElement("DIV");
	for (let e of elements)
		div.appendChild(e);
	return div;
}

function createTextNode(elementType, text) {
	let e = document.createElement(elementType);
	let t = document.createTextNode(text);
	e.appendChild(t);
	return e;
}

function empty(element) {
	for (;;) {
		let child = Polymer.dom(element).firstChild;
		if (!child)
			break;
		Polymer.dom(element).removeChild(child);
	}
}

function appendTextNode(paragraph, text) {
	let t = document.createTextNode(text);
	paragraph.appendChild(t);
}

let chain = [];
let running = false;

function consume_next() {
	console.log("queue consume");
	let next = chain.shift();
	if (!next) {
		console.log("queue runner terminate");
		running = false;
		return null;
	}

	return new Promise(next).then(
		() => consume_next()
	);
}

function queue(cb) {
	console.log("queue add");
	chain.push(cb);
	if (!running) {
		console.log("queue runner start");
		running = true;
		consume_next();
	}
}

Polymer({
	is: "ts-transcript",

	ready: function() {
		this.roomDiv = null;
		this.titleT = null;
		this.bodyT = null;
		this.choicesT = null;
		this.bodyDom = null;
		this.choicesDom = null;
	},

	newRoom: function({title, bodyDom, choicesDom}) {
		queue(
			(pass, fail) => {
				console.log("-> newRoom");
				let $ = this.$;

				this.roomDiv = divWithClass("transcript");
				this.titleT = document.createElement("ts-transformer");
				this.bodyT = document.createElement("ts-transformer");
				this.choicesT = null;

				this.bodyDom = bodyDom;
				this.choicesDom = choicesDom;

				$.container.appendChild(this.roomDiv);
				this.roomDiv.appendChild(this.titleT);
				this.roomDiv.appendChild(this.bodyT);

				this.titleT.content = createTextNode("H1", title);
				this.bodyT.content = createDiv(bodyDom, choicesDom);

				this.bodyT.then(pass);
			}
		);
	},

	hideChoices: function() {
		queue(
			(pass, fail) => {
				console.log("-> hideChoices");
				if (this.choicesT == null) {
					/* This room hasn't been split yet; do so. */
					
					this.bodyT.replaceWithThrowaway();
					this.bodyT.content = this.bodyDom;

					this.choicesT = document.createElement("ts-transformer");
					console.log("choicesT", this.choicesT);

					this.bodyT.then(pass);
				} else {
					this.choicesT.content = null;
					this.choicesT.then(pass);
				}
			}
		);
	},

	showChoices: function() {
		queue(
			(pass, fail) => {
				console.log("-> showChoices");
					console.log("choicesT", this.choicesT);
				if (this.choicesT == null) {
					/* This room hasn't been split yet; choices are already
					visible. */
					pass();
				} else if (this.choicesT.content != null) {
					/* Choices are already visible. */
					pass();
				} else {
					this.roomDiv.appendChild(this.choicesT);
					this.choicesT.content = this.choicesDom;
					this.choicesT.then(pass);
				}
			}
		);
	},

	updateRoom: function({title, bodyDom, choicesDom}) {
		queue(
			(pass, fail) => {
				console.log("-> updateRoom");

				this.titleT.content = createTextNode("H1", title);

				this.bodyDom = bodyDom;
				this.choicesDom = choicesDom;

				if (this.choicesT == null) {
					/* Unseparated room description. */

					this.bodyT.content = createDiv(bodyDom, choicesDom);
					this.bodyT.then(pass);
				} else {
					/* Split body and choices. */

					this.bodyT.content = bodyDom;
					this.choicesT.content = choicesDom;
					this.bodyT.then(pass);
				}
			}
		);
	},

	append: function(text) {
		let room = this._currentRoom;
		queue(
			(pass, fail) => {
				let t = document.createElement("ts-transformer");
				t.content = createTextNode("P", text);
				this.roomDiv.appendChild(t);

				t.then(pass);
			}
		);
	}
});

})();
</script>
</dom-module>

