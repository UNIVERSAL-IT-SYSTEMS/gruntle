<link rel="import" href="ts-transformer.html">
<link rel="import" href="ts-globals.html">

<style>
	.transcript {
		text-rendering: optimizeLegibility;
		font-family: 'Lora', serif;
		text-align: justify;
		line-height: 1.8em;
		overflow-wrap: break-word;
		word-wrap: break-word;
		margin: 0;
		padding: 0;
	}

	.transcript P {
		margin: 0;
		padding-top: 0;
		padding-bottom: 0.5em;
	}

	.transcript H1 {
		font-size: 120%;
		font-weight: bold;
		margin: 0;
		padding-top: 0.5em;
		padding-bottom: 1em;
	}

	.transcript H3 {
		font-size: 100%;
		font-weight: bold;
		margin: 0;
		padding-top: 1em;
		padding-bottom: 0.5em;
	}

	.transcript UL {
		margin: 0;
		padding-top: 0.2em;
		padding-bottom: 0.2em;
	}

	.transcript UL P {
		margin: 0;
		padding-bottom: 0.5em;
	}

</style>

<dom-module id="ts-transcript">
<template>
	<style>

	:host {
		@apply(--layout-vertical);
		display: block;
		min-height: 100%;
		font-size: 110%;
	}

	#container {
		@apply(--layout-flex);
	}

	#container li p {
		@apply(--transcript-choice);
	}

	#blank {
		height: 200vh;
	}

	#textbox {
		position: fixed;
		bottom: 1em;
		left: 1em;
		right: 1em;
	}
	</style>

	<ts-globals id="globals"></ts-globals>
	<div id="container" class="transcript"></div>
	<div id="blank"></div>
</template>
<script>
(function () {
"use strict";

let G = null;

function createElementWithClass(elementType, c) {
	let e = document.createElement(elementType);
	e.setAttribute("class", c);
	return e;
}

function createDiv(...elements) {
	let div = document.createElement("DIV");
	for (let e of elements)
		div.appendChild(e);
	return div;
}

function createTextNode(elementType, text) {
	let e = document.createElement(elementType);
	let t = document.createTextNode(text);
	e.appendChild(t);
	return e;
}

function empty(element) {
	for (;;) {
		let child = Polymer.dom(element).firstChild;
		if (!child)
			break;
		Polymer.dom(element).removeChild(child);
	}
}

function appendTextNode(paragraph, text) {
	let t = document.createTextNode(text);
	paragraph.appendChild(t);
}

let chain = [];
let running = false;

function consume_next() {
	console.log("queue consume");
	let next = chain.shift();
	if (!next) {
		console.log("queue runner terminate");
		running = false;
		return null;
	}

	return new Promise(next).then(
		() => consume_next()
	);
}

function queue(cb) {
	console.log("queue add");
	chain.push(cb);
	if (!running) {
		console.log("queue runner start");
		running = true;
		consume_next();
	}
}

Polymer({
	is: "ts-transcript",

	ready: function() {
		G = this.$.globals.G;

		this.roomDiv = null;
		this.titleT = null;
		this.bodyT = null;
		this.choicesT = null;
		this.bodyDom = null;
		this.choicesDom = null;
		this.mark = null;
	},

	newRoom: function({title, bodyDom, choicesDom}) {
		queue(
			(pass, fail) => {
				console.log("-> newRoom");
				let $ = this.$;

				this.roomDiv = createElementWithClass("DIV", "transcript");
				this.titleT = document.createElement("ts-transformer");
				this.bodyT = document.createElement("ts-transformer");
				this.choicesT = document.createElement("ts-transformer");

				this.bodyDom = bodyDom;
				this.choicesDom = choicesDom;

				$.container.appendChild(this.roomDiv);
				this.roomDiv.appendChild(this.titleT);
				this.roomDiv.appendChild(this.bodyT);
				this.roomDiv.appendChild(this.choicesT);

				this.titleT.content = createTextNode("H1", title);
				this.bodyT.content = bodyDom;
				this.choicesT.content = choicesDom;

				this.bodyT.then(pass);
			}
		);
	},

	hideChoices: function() {
		queue(
			(pass, fail) => {
				console.log("-> hideChoices");
				this.choicesT.content = null;
				this.choicesT.then(pass);
			}
		);
	},

	showChoices: function() {
		queue(
			(pass, fail) => {
				console.log("-> showChoices");
				if (this.choicesT.content != null) {
					/* Choices are already visible. */
					pass();
				} else {
					this.roomDiv.appendChild(this.choicesT);

					this.choicesT.content = this.choicesDom;
					this.choicesT.then(pass);
				}
			}
		);
	},

	updateRoom: function({title, bodyDom, choicesDom}) {
		queue(
			(pass, fail) => {
				console.log("-> updateRoom");

				this.titleT.content = createTextNode("H1", title);

				this.bodyDom = bodyDom;
				this.choicesDom = choicesDom;

				this.bodyT.content = bodyDom;
				this.choicesT.content = choicesDom;
				this.bodyT.then(pass);
			}
		);
	},

	append: function(text) {
		let room = this._currentRoom;
		queue(
			(pass, fail) => {
				let t = document.createElement("ts-transformer");
				t.animation = "fast-fade-zoom";
				t.content = createTextNode("P", text);
				this.roomDiv.appendChild(t);

				t.then(pass);
			}
		);
	},

	setMark: function() {
		queue(
			(pass, fail) => {
				this.mark = createElementWithClass("DIV", "mark");
				this.roomDiv.appendChild(this.mark);

				pass();
			}
		);
	},

	scrollToMark: function() {
		queue(
			(pass, fail) => {
				if (this.mark == null)
					return;

				let s = G.findScrollable(this);
				if (s != null) {
					let a = new KeyframeEffect(
						s,
						[],
						{
							duration: 1000,
							easing: "ease-in-out"
						}
					);
					let starty = s.scrollTop;
					a.onsample = (fraction, e, a) => {
						let endy = G.findRelativeYOffset(this.mark, s);

						if (fraction != null)
							s.scrollTop = starty - fraction*(starty-endy);
					};

					document.timeline.play(a);
				}
				
				pass();
			}
		);
	},
});

})();
</script>
</dom-module>

